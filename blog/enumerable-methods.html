<!DOCTYPE HTML>
<html>

<head>
  <title>Phase 0 Blog</title>
  <link type="text/css" rel="stylesheet" href="../stylesheets/default.css" />
  <link type="text/css" rel="stylesheet" href="../stylesheets/blog.css" />
  <link href='https://fonts.googleapis.com/css?family=Raleway' rel='stylesheet' type='text/css'>
</head>

<body>

    <header>
      <nav id="links">
        <div class="center">
          <h1><a href="../index.html">Dan Turcza, Web Developer</a></h1>
        </div>
        <div class="box" id="top">
          <h2><a href="../about.html">About Me</a></h1>
        </div>
        <div class="box" id="left">
          <h2><a href="../projects/index.html">Projects</a></h1>
        </div>
        <div class="box" id="right">
          <h2><a href="index.html">Blog</a></h1>
        </div>
        <div class="box" id="bottom">
          <h2><a href="../contact.html">Contact</a></h1>
        </div>
      </nav>
    </header>



    <section id="title">
    <h2>Enumerable methods: group_by</h2>
        <p>11/15/2015</p>
        <p>Dan Turcza</p>
        <p>Tags</p>
    </section>

<section id="main-post">
<p>
        Today, we're going to learn a bit about an Enumerable method called group_by. Enumerable methods are mixed in with arrays and hashes, so you might use group_by with an array or a hash. Many of these Enumerable methods are useful for sorting, filtering, or aggregating arrays and hashes, and group_by is a great example.
    </p>
    <p>
        If you think about what a group_by might do based on the name (or if you're familiar with SQL), you might guess that it will return items in the original list in different GROUPS based on their values. And that's exactly right. You pass group_by an object and a code block that describes what you want your groups to be, and group_by returns the groupings. For instance, a typical example is:
    </p>
    <p>
        <pre><code>num_array = [1,2,3,4,5,6,7,8,9]
num_array.group_by { |x| x % 3 }
=> { 1: [1,4,7], 2: [2,5,8], 0: [3, 6, 9] }
</code></pre>
    </p>
    <p>
        So what happened? If you look in the block we passed to group_by, you'll see that it can return one of 3 values based on the % or modulus function. No matter what the number is, x % 3 will return 0, 1, or 2, the possible remainders when we divide a number by 3. So group_by is taking all of the numbers that divide evenly (remainder is 0) and putting them in an array, then putting it in a hash with that 0 value. And same thing with the numbers that leave a remainder of one and two. So, to summarize, you are returned a hash where the key is a particular outcome of your block, and the values are arrays containing elements that resulted in those outcomes.
    </p>
    <p>
        Another great example would be grouping your friends based on the first letter of their names. So:
    </p>
    <p>
            <pre><code>friends = ["Alice","Alex","Anthony","Barry","Blake","Bruno","Steve"]
friends.group_by { |x| x[0] }
=> { "A": ["Alice","Alex","Anthony"], "B": ["Barry","Blake","Bruno"], "S": ["Steve"]}
</code></pre>
    </p>
    <p>
        Poor Steve. Anyway, the sky is the limit. Note that for cases where you just need some of the values (e.g. only my friends whose names start with "A" or only my friends who aren't "Steve"), you should probably use something like <a href=http://ruby-doc.org/core-2.2.3/Enumerable.html#method-i-select">select</a> or <a href="http://ruby-doc.org/core-2.2.3/Enumerable.html#method-i-reject">reject</a>. And if you have the simpler case of just having a binary, true-false split, look into using the <a href="http://ruby-doc.org/core-2.2.3/Enumerable.html#method-i-partition">partition</a> method, which has the sometimes-advantage of returning an array of two arrays (first the true values, then the false/nil ones), rather than a hash.
    </p>
    <p>
        Happy grouping!
    </p>
</section>

<section id = "comments">
<h3>Comments</h3>
    <!--
    <article>Comment 1</article>
    <article>Comment 2</article>
    <article>Comment 3</article>
  -->
</section>



</body>

</html>
