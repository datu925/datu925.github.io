<!DOCTYPE HTML>
<html>

<head>
  <title>Phase 0 Blog</title>
  <link type="text/css" rel="stylesheet" href="../stylesheets/default.css" />
  <link type="text/css" rel="stylesheet" href="../stylesheets/blog.css" />
  <link href='https://fonts.googleapis.com/css?family=Raleway' rel='stylesheet' type='text/css'>
</head>

<body>

    <header>
      <nav id="links">
        <div class="center">
          <h1><a href="../index.html">Dan Turcza, Web Developer</a></h1>
        </div>
        <div class="box" id="top">
          <h2><a href="../about.html">About Me</a></h1>
        </div>
        <div class="box" id="left">
          <h2><a href="../projects/index.html">Projects</a></h1>
        </div>
        <div class="box" id="right">
          <h2><a href="index.html">Blog</a></h1>
        </div>
        <div class="box" id="bottom">
          <h2><a href="../contact.html">Contact</a></h1>
        </div>
      </nav>
    </header>



    <section id="title">
    <h2>Big O Notation</h2>
        <p>1/10/2016</p>
        <p>Dan Turcza</p>
        <p>Tagged to: math</p>
    </section>

<section id="main-post">
    <p>
        I'll be writing today about Big O notation, which is a way for programmers to describe how their algorithms (or functions or programs; I will refer to algorithms for simplicity going forward) respond to increases in the size of the input. Often, this is a way of trying to talk about the complexity of an algorithm.
    </p>
    <p>
        Big O notation tells you how the number of operations or steps in an algorithm will grow as the input to the algorithm grows. For instance, if my algorithm is simply to print the first letter of a word, it doesn't matter whether the word is five letters long or five hundred. There's one step - the printing of the letter - and even as the input grows very large, there is no increase in runtime. This is called constant time or O(1).
    </p>
    <p>
        But if I was to need an algorithm that printed out every letter in that word, I would probably implement some kind of loop. And then the size of my input would very much impact the number of operations - if my word is 5 letters long, I need five operations, but if it is 1000 letters long, I need 1000 operations. For this kind of algorithm, we'd say it's O(n) or linear time.
    </p>
    <p>
        What if I want to print every letter twice, you might ask. Would the Big O notation of that be O(2n)? In some sense, yes, but for Big O notation, we only care about large differences in operations or complexity, and so we drop off any constants. For our purposes, an algorithm for printing every letter twice or three times still responds similarly to changes in input as an algorithm that prints it once. So we would say those algorithms are also O(n).
    </p>
    <p>
        As indicated by <a href="http://web.mit.edu/16.070/www/lecture/big_o.pdf">this article</a>, there are many other common Big O types, and in <a href="http://bigocheatsheet.com/">this cheat sheet</a>, you can see the Big O notation for many typical actions, like searching for a value in an array.
    </p>
    <p>
        Why is this important? In many cases, it's an academic exercise. But practically speaking, if two algorithms accomplish the same task, the one with a "smaller" Big O is preferable, unless you know your input will always be small. If your input could grow to millions or billions of lines or objects, there will be a big runtime difference between something that is O(1), O(log n), or O(n). And formalizing this thinking often lets us make better coding decisions.
    </p>
    <p>
        For instance, if you have an algorithm that needs to search for data by a key, you would probably put it in a hash (or dictionary or object) rather than an array. That's just intuitive, but it also makes sense from a performance perspective: searching an array for a particular value is O(n) - the longer the array, the more longer your search operation will take, because you need to iterate through the array to look for it. Whereas for a hash, it doesn't matter how long the hash is - the key accesses the value in O(1) time. Often, building a smart algorithm is about recognizing those different choices and choosing a data structure well-suited for the job, so you can keep your Big O as small as possible.
    </p>
</section>

<section id = "comments">
<h3>Comments</h3>
    <!--
    <article>Comment 1</article>
    <article>Comment 2</article>
    <article>Comment 3</article>
  -->
</section>



</body>

</html>